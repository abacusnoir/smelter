# ADT Bootstrap Fix

## Problem Statement

When running pattern matching expressions with the compiled `smt` binary, users encountered "undefined function" errors for ADT accessor functions. The specific error occurred when executing commands like:

```bash
./smt eval '(match (Ok 1) ((Ok x) (+ x 1)) ((Err _) 0))'
```

This would fail with errors indicating that accessor functions for ADT constructors (like `result/ok-_0` for Result types) were not available at runtime, even though they should have been generated by the Coalton compiler.

## Root Cause Analysis (The "Chicken-and-Egg" Problem)

The issue stems from a fundamental circular dependency in how Coalton's pattern matching system works:

### How Coalton Pattern Matching Works

1. When Coalton compiles a `match` expression, it needs ADT accessor functions like `|result/ok-_0|` to extract values from pattern-matched objects
2. These accessor functions are **not pre-written in library files** - they are **generated on-demand** by the `match` macro itself
3. The first time you compile a `match` expression, the macro generates the required accessor functions and type predicates
4. Subsequent `match` expressions use the already-generated functions

### The Bootstrap Problem in Saved Binaries

In a standalone binary created with `sb-ext:save-lisp-and-die`:

1. **During Build**: Pattern matching works fine because we're in a live SBCL session where the macro can generate functions on-demand
2. **In Saved Binary**: The generated accessor functions **are not included** in the saved image
3. **At Runtime**: When a user runs a `match` expression, the macro tries to call accessor functions that **don't exist**
4. **Result**: "Undefined function" errors

### The IKEA Analogy

This is like IKEA packing a piece of furniture in a box:
- They include all the **pre-manufactured parts** (the ADT constructors like `Ok` and `Err` work fine)
- They include the **instruction manual** (the `match` macro compiles correctly)
- But they **forget to pack the Allen wrench** (the accessor functions needed for assembly)
- When the customer (user) tries to assemble it at home (runtime), they have everything except the essential tool needed for the final step

## The "Build-Time Bootstrapping" Solution

The definitive solution, validated by examining the working `coalton-playground` project, is **Build-Time Bootstrapping**. This approach forces the generation of all necessary runtime machinery during the image creation process, ensuring these components are saved into the final executable.

### Implementation Strategy

The fix involves adding a comprehensive bootstrapping code block to `build/create-image.lisp` that:

1. **Creates a Bootstrap Package**: A temporary `coalton-bootstrap` package with access to Coalton and the prelude.
2. **Forces Pattern Matching Compilation**: Defines dummy functions that use `match` expressions on all core ADT types.
3. **Triggers Runtime Evaluation**: Executes a pattern matching expression to ensure any lazy runtime initialization occurs.

### Code Implementation

```lisp
;;; =================================================================
;;;
;;;  Build-Time Bootstrapping for Coalton ADT Pattern Matching
;;;
;;; =================================================================

(format t "--> Bootstrapping Coalton ADT pattern matching...~%")
(handler-case
    (progn
      (defpackage #:coalton-bootstrap
        (:use #:coalton #:coalton-prelude))
      (in-package #:coalton-bootstrap)

      (coalton:coalton-toplevel
        ;; Match on Result
        (declare bootstrap-result ((Result Integer String) -> Integer))
        (define (bootstrap-result x)
          (match x
            ((Ok n) n)
            ((Err _) 0)))

        ;; Match on Tuple
        (declare bootstrap-tuple ((Tuple Integer String) -> Integer))
        (define (bootstrap-tuple x)
          (match x
            ((Tuple n _) n)))

        ;; Match on List
        (declare bootstrap-list ((List Integer) -> Integer))
        (define (bootstrap-list x)
          (match x
            ((Cons h _) h)
            ((Nil) 0)))

        ;; Match on Optional
        (declare bootstrap-optional ((Optional Integer) -> Integer))
        (define (bootstrap-optional x)
          (match x
            ((Some n) n)
            ((None) 0))))

      ;; Also EVALUATE a match to trigger any lazy runtime setup
      (eval '(coalton:coalton
              (match (coalton-prelude:Ok 1)
                ((coalton-prelude:Ok x) (+ x 1))
                ((coalton-prelude:Err _) 0))))

      (format t "--> Bootstrap complete.~%"))
  (error (e)
    (format *error-output* "ERROR during ADT bootstrap: ~A~%" e)
    (uiop:quit 1)))
(in-package #:cl-user) ; Return to a clean package
```

### Why This Works

1. **Comprehensive Coverage**: Forces compilation of `match` expressions for all core ADT types during the build process
2. **Runtime Generation**: Lets Coalton's own machinery generate the accessor functions naturally using its built-in mechanisms
3. **Evaluation Trigger**: The `eval` call ensures that pattern matching is actually executed at build time, triggering any lazy initialization
4. **Package Isolation**: Uses a temporary bootstrap package to avoid polluting the main namespace

## The Role of `:purify nil`

The final component of the fix is adding `:purify nil` to the `sb-ext:save-lisp-and-die` call:

```lisp
(sb-ext:save-lisp-and-die core-path
                          :executable nil
                          :compression t
                          :save-runtime-options nil
                          :purify nil) ; <-- Critical addition
```

### Why `:purify nil` is Essential

SBCL's default "purification" process during image saving performs aggressive optimization that can remove:
- Dynamically generated functions that appear unused
- Runtime accessor functions created during bootstrap
- Internal Coalton compiler state needed for pattern matching

By setting `:purify nil`, we ensure that all the runtime machinery generated during the bootstrap process is preserved in the final executable, even if SBCL's static analysis cannot determine that these components will be needed at runtime.

## Success Criteria

After implementing this fix, the following command should work correctly and return `2`:

```bash
./smt eval '(match (Ok 1) ((Ok x) (+ x 1)) ((Err _) 0))'
```

This demonstrates that:
1. The Result ADT accessor functions are available
2. Pattern matching compilation works correctly at runtime
3. The runtime evaluation produces the expected result

Additional test cases should also work:

```bash
# Tuple pattern matching
./smt eval '(match (Tuple 1 2) ((Tuple a b) (+ a b)))'  # Should return 3

# Optional pattern matching
./smt eval '(match (Some 5) ((Some x) x) ((None) 0))'  # Should return 5

# List pattern matching
./smt eval '(match (Cons 1 (Nil)) ((Cons h _) h) ((Nil) 0))'  # Should return 1
```

## Technical Background

This fix addresses a fundamental challenge in standalone Lisp executables: preserving the dynamic compilation environment needed for macro expansion at runtime. While Coalton's `match` macro is powerful and flexible, its dependency on dynamically generated accessor functions requires careful handling in the build process to ensure these functions survive the transition from build-time to runtime.

The Build-Time Bootstrapping strategy ensures that all necessary runtime components are "pre-warmed" during the build process, creating a self-contained executable that can handle pattern matching without requiring the full Coalton compilation environment at runtime.

## Future Considerations

This bootstrap approach should be extended if:
1. New core ADT types are added to Coalton's prelude
2. Additional pattern matching features require runtime compilation support
3. User-defined ADTs need similar bootstrap treatment

The bootstrap code block provides a template that can be extended to cover additional ADT types as needed. Simply add new `match` expressions following the same pattern for any new ADT types that require pattern matching support.